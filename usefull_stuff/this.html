<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>this</title>
</head>
<body>
    <script>
        let a = 10;
        let b = 20;

        const someObj = {
            name:"Pavlo",
            summ: () => this, //arrow function has "this" in the outer scope, same as the object someObj itself, NOT in "someObj"!!!
            summ2() {
                return this
            },
            otherObj: {
                summ3: () => this, //??? 41:40 video https://www.youtube.com/watch?v=SL-cIGsp6_w
            }
        }

        console.log(someObj.summ()); // "() =>" function >> Window {window: Window, self: Window, document: document, name: '', location: Location, …}
        console.log(someObj.summ2()); // "classic function" >> {name: 'Pavlo', summ: ƒ, summ2: ƒ}
        console.log(someObj.otherObj.summ3()); // "() =>" function >> Window {window: Window, self: Window, document: document, name: '', 
        
        /** 
         * this - контекст виклику функції, те в якій області вона викликається, якщо це метод об'єкта - то this буде цей об'єкт (але не завжди...). 
         * arrow functions "() => {}" don't have a "this"!
         * 
        */

        window.tests = 155;
        function printWindowTests(){
            console.log(this.tests);
        }
        printWindowTests() //155, "this" для printWindowTests() буде тим, що йде зліва від виклику функції, у даному випадку - глобальний об'єкт "window"!

        /** 
         * how to bind this?
         * - callable way
         * - non-callable way
        */

        /*****  callable:  *****/

        const heroObjHOTS = {
            heroName: "Alarak",
        } 

        const heroObjOW = {
            heroName: "Hanzo",
        } 

        const heroObjTanks = {
            heroName: "Conqueror",
        } 

        function returnHeroName(...args) {
            console.log({ args });
            return this.heroName 
        }
        
        // console.log(heroObj.returnHeroName()); >> /* "Uncaught TypeError: heroObj.returnHeroName is not a function" */
        
        console.log(returnHeroName.call(heroObjHOTS)); // >> Alarak, used ".call(heroObjHOTS)"


        /** 
        apply
        */

        console.log(returnHeroName.apply(heroObjTanks)); // >> Conqueror, used ".apply(heroObjTanks)"

        /** 
        difference between "call" and "apply": 
            for "call" we pass arguments separated by comma
            for "apply" we pass only 1 argument, for example array, which holds arguments separated by comma

        */
        console.log(returnHeroName.call(heroObjOW, 200, 400)); // call >> args = [ 200, 400 ]

        /* console.log(returnHeroName.apply(heroObjOW, 200, 400)); // apply >> "Uncaught TypeError: CreateListFromArrayLike called on non-object" */

        console.log(returnHeroName.apply(heroObjOW, [200, 400])); // call >> args = [ 200, 400 ]

        // functions called with methods call/apply are invoked immediately

        /*****  non-callable(bind):  *****/

        const binded = returnHeroName.bind(heroObjHOTS, 500); //function is not invoked if "binded"

        console.log(binded());  // to invoke function, run "binded" as function, >> Alarak

    </script>
</body>
</html>
